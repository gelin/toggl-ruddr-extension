{"version":3,"file":"content.js","sources":["../../node_modules/svelte/src/internal/client/dom/blocks/if.js","../../node_modules/svelte/src/internal/shared/attributes.js","../../node_modules/svelte/src/internal/client/dom/elements/class.js","../../node_modules/svelte/src/internal/client/dom/elements/style.js","../../node_modules/svelte/src/internal/client/reactivity/props.js","../../src/content/ReportPanel.svelte","../../src/content/TogglButton.svelte","../../src/content/content.ts"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START, HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn\n * @param {[number,number]} [elseif]\n * @returns {void}\n */\nexport function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {\n\tif (hydrating && root_index === 0) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (\n\t\t/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,\n\t\tflag = true\n\t) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating && hydrate_index !== -1) {\n\t\t\tif (root_index === 0) {\n\t\t\t\tconst data = read_hydration_instruction(anchor);\n\n\t\t\t\tif (data === HYDRATION_START) {\n\t\t\t\t\thydrate_index = 0;\n\t\t\t\t} else if (data === HYDRATION_START_ELSE) {\n\t\t\t\t\thydrate_index = Infinity;\n\t\t\t\t} else {\n\t\t\t\t\thydrate_index = parseInt(data.substring(1));\n\t\t\t\t\tif (hydrate_index !== hydrate_index) {\n\t\t\t\t\t\t// if hydrate_index is NaN\n\t\t\t\t\t\t// we set an invalid index to force mismatch\n\t\t\t\t\t\thydrate_index = condition ? Infinity : -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst is_else = hydrate_index > root_index;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t\thydrate_index = -1; // ignore hydration in next else if\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else if (fn) {\n\t\t\t\tconsequent_effect = branch(() => fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (fn) {\n\t\t\t\talternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","import { escape_html } from '../../escaping.js';\nimport { clsx as _clsx } from 'clsx';\n\n/**\n * `<div translate={false}>` should be rendered as `<div translate=\"no\">` and _not_\n * `<div translate=\"false\">`, which is equivalent to `<div translate=\"yes\">`. There\n * may be other odd cases that need to be added to this list in future\n * @type {Record<string, Map<any, string>>}\n */\nconst replacements = {\n\ttranslate: new Map([\n\t\t[true, 'yes'],\n\t\t[false, 'no']\n\t])\n};\n\n/**\n * @template V\n * @param {string} name\n * @param {V} value\n * @param {boolean} [is_boolean]\n * @returns {string}\n */\nexport function attr(name, value, is_boolean = false) {\n\tif (value == null || (!value && is_boolean)) return '';\n\tconst normalized = (name in replacements && replacements[name].get(value)) || value;\n\tconst assignment = is_boolean ? '' : `=\"${escape_html(normalized, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\n/**\n * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.\n * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)\n * @param  {any} value\n */\nexport function clsx(value) {\n\tif (typeof value === 'object') {\n\t\treturn _clsx(value);\n\t} else {\n\t\treturn value ?? '';\n\t}\n}\n\nconst whitespace = [...' \\t\\n\\r\\f\\u00a0\\u000b\\ufeff'];\n\n/**\n * @param {any} value\n * @param {string | null} [hash]\n * @param {Record<string, boolean>} [directives]\n * @returns {string | null}\n */\nexport function to_class(value, hash, directives) {\n\tvar classname = value == null ? '' : '' + value;\n\n\tif (hash) {\n\t\tclassname = classname ? classname + ' ' + hash : hash;\n\t}\n\n\tif (directives) {\n\t\tfor (var key in directives) {\n\t\t\tif (directives[key]) {\n\t\t\t\tclassname = classname ? classname + ' ' + key : key;\n\t\t\t} else if (classname.length) {\n\t\t\t\tvar len = key.length;\n\t\t\t\tvar a = 0;\n\n\t\t\t\twhile ((a = classname.indexOf(key, a)) >= 0) {\n\t\t\t\t\tvar b = a + len;\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(a === 0 || whitespace.includes(classname[a - 1])) &&\n\t\t\t\t\t\t(b === classname.length || whitespace.includes(classname[b]))\n\t\t\t\t\t) {\n\t\t\t\t\t\tclassname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn classname === '' ? null : classname;\n}\n\n/**\n *\n * @param {Record<string,any>} styles\n * @param {boolean} important\n */\nfunction append_styles(styles, important = false) {\n\tvar separator = important ? ' !important;' : ';';\n\tvar css = '';\n\n\tfor (var key in styles) {\n\t\tvar value = styles[key];\n\t\tif (value != null && value !== '') {\n\t\t\tcss += ' ' + key + ': ' + value + separator;\n\t\t}\n\t}\n\n\treturn css;\n}\n\n/**\n * @param {string} name\n * @returns {string}\n */\nfunction to_css_name(name) {\n\tif (name[0] !== '-' || name[1] !== '-') {\n\t\treturn name.toLowerCase();\n\t}\n\treturn name;\n}\n\n/**\n * @param {any} value\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles]\n * @returns {string | null}\n */\nexport function to_style(value, styles) {\n\tif (styles) {\n\t\tvar new_style = '';\n\n\t\t/** @type {Record<string,any> | undefined} */\n\t\tvar normal_styles;\n\n\t\t/** @type {Record<string,any> | undefined} */\n\t\tvar important_styles;\n\n\t\tif (Array.isArray(styles)) {\n\t\t\tnormal_styles = styles[0];\n\t\t\timportant_styles = styles[1];\n\t\t} else {\n\t\t\tnormal_styles = styles;\n\t\t}\n\n\t\tif (value) {\n\t\t\tvalue = String(value)\n\t\t\t\t.replaceAll(/\\s*\\/\\*.*?\\*\\/\\s*/g, '')\n\t\t\t\t.trim();\n\n\t\t\t/** @type {boolean | '\"' | \"'\"} */\n\t\t\tvar in_str = false;\n\t\t\tvar in_apo = 0;\n\t\t\tvar in_comment = false;\n\n\t\t\tvar reserved_names = [];\n\n\t\t\tif (normal_styles) {\n\t\t\t\treserved_names.push(...Object.keys(normal_styles).map(to_css_name));\n\t\t\t}\n\t\t\tif (important_styles) {\n\t\t\t\treserved_names.push(...Object.keys(important_styles).map(to_css_name));\n\t\t\t}\n\n\t\t\tvar start_index = 0;\n\t\t\tvar name_index = -1;\n\n\t\t\tconst len = value.length;\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar c = value[i];\n\n\t\t\t\tif (in_comment) {\n\t\t\t\t\tif (c === '/' && value[i - 1] === '*') {\n\t\t\t\t\t\tin_comment = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (in_str) {\n\t\t\t\t\tif (in_str === c) {\n\t\t\t\t\t\tin_str = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (c === '/' && value[i + 1] === '*') {\n\t\t\t\t\tin_comment = true;\n\t\t\t\t} else if (c === '\"' || c === \"'\") {\n\t\t\t\t\tin_str = c;\n\t\t\t\t} else if (c === '(') {\n\t\t\t\t\tin_apo++;\n\t\t\t\t} else if (c === ')') {\n\t\t\t\t\tin_apo--;\n\t\t\t\t}\n\n\t\t\t\tif (!in_comment && in_str === false && in_apo === 0) {\n\t\t\t\t\tif (c === ':' && name_index === -1) {\n\t\t\t\t\t\tname_index = i;\n\t\t\t\t\t} else if (c === ';' || i === len - 1) {\n\t\t\t\t\t\tif (name_index !== -1) {\n\t\t\t\t\t\t\tvar name = to_css_name(value.substring(start_index, name_index).trim());\n\n\t\t\t\t\t\t\tif (!reserved_names.includes(name)) {\n\t\t\t\t\t\t\t\tif (c !== ';') {\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar property = value.substring(start_index, i).trim();\n\t\t\t\t\t\t\t\tnew_style += ' ' + property + ';';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart_index = i + 1;\n\t\t\t\t\t\tname_index = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (normal_styles) {\n\t\t\tnew_style += append_styles(normal_styles);\n\t\t}\n\n\t\tif (important_styles) {\n\t\t\tnew_style += append_styles(important_styles, true);\n\t\t}\n\n\t\tnew_style = new_style.trim();\n\t\treturn new_style === '' ? null : new_style;\n\t}\n\n\treturn value == null ? null : String(value);\n}\n","import { to_class } from '../../../shared/attributes.js';\nimport { hydrating } from '../hydration.js';\n\n/**\n * @param {Element} dom\n * @param {boolean | number} is_html\n * @param {string | null} value\n * @param {string} [hash]\n * @param {Record<string, any>} [prev_classes]\n * @param {Record<string, any>} [next_classes]\n * @returns {Record<string, boolean> | undefined}\n */\nexport function set_class(dom, is_html, value, hash, prev_classes, next_classes) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev = dom.__className;\n\n\tif (\n\t\thydrating ||\n\t\tprev !== value ||\n\t\tprev === undefined // for edge case of `class={undefined}`\n\t) {\n\t\tvar next_class_name = to_class(value, hash, next_classes);\n\n\t\tif (!hydrating || next_class_name !== dom.getAttribute('class')) {\n\t\t\t// Removing the attribute when the value is only an empty string causes\n\t\t\t// performance issues vs simply making the className an empty string. So\n\t\t\t// we should only remove the class if the value is nullish\n\t\t\t// and there no hash/directives :\n\t\t\tif (next_class_name == null) {\n\t\t\t\tdom.removeAttribute('class');\n\t\t\t} else if (is_html) {\n\t\t\t\tdom.className = next_class_name;\n\t\t\t} else {\n\t\t\t\tdom.setAttribute('class', next_class_name);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = value;\n\t} else if (next_classes && prev_classes !== next_classes) {\n\t\tfor (var key in next_classes) {\n\t\t\tvar is_present = !!next_classes[key];\n\n\t\t\tif (prev_classes == null || is_present !== !!prev_classes[key]) {\n\t\t\t\tdom.classList.toggle(key, is_present);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn next_classes;\n}\n","import { to_style } from '../../../shared/attributes.js';\nimport { hydrating } from '../hydration.js';\n\n/**\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {Record<string, any>} prev\n * @param {Record<string, any>} next\n * @param {string} [priority]\n */\nfunction update_styles(dom, prev = {}, next, priority) {\n\tfor (var key in next) {\n\t\tvar value = next[key];\n\n\t\tif (prev[key] !== value) {\n\t\t\tif (next[key] == null) {\n\t\t\t\tdom.style.removeProperty(key);\n\t\t\t} else {\n\t\t\t\tdom.style.setProperty(key, value, priority);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {string | null} value\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles]\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles]\n */\nexport function set_style(dom, value, prev_styles, next_styles) {\n\t// @ts-expect-error\n\tvar prev = dom.__style;\n\n\tif (hydrating || prev !== value) {\n\t\tvar next_style_attr = to_style(value, next_styles);\n\n\t\tif (!hydrating || next_style_attr !== dom.getAttribute('style')) {\n\t\t\tif (next_style_attr == null) {\n\t\t\t\tdom.removeAttribute('style');\n\t\t\t} else {\n\t\t\t\tdom.style.cssText = next_style_attr;\n\t\t\t}\n\t\t}\n\n\t\t// @ts-expect-error\n\t\tdom.__style = value;\n\t} else if (next_styles) {\n\t\tif (Array.isArray(next_styles)) {\n\t\t\tupdate_styles(dom, prev_styles?.[0], next_styles[0]);\n\t\t\tupdate_styles(dom, prev_styles?.[1], next_styles[1], 'important');\n\t\t} else {\n\t\t\tupdate_styles(dom, prev_styles, next_styles);\n\t\t}\n\t}\n\n\treturn next_styles;\n}\n","/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport { get, untrack } from '../runtime.js';\nimport * as e from '../errors.js';\nimport { LEGACY_PROPS, STATE_SYMBOL } from '#client/constants';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (!p) continue;\n\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\n\t\t\tfor (const key of Object.getOwnPropertySymbols(p)) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @param {Derived} current_value\n * @returns {boolean}\n */\nfunction has_destroyed_component_ctx(current_value) {\n\treturn current_value.ctx?.d ?? false;\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\n\tvar get_fallback = () => {\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\n\t\t\tfallback_value = lazy\n\t\t\t\t? untrack(/** @type {() => V} */ (fallback))\n\t\t\t\t: /** @type {V} */ (fallback);\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\t/** @type {((v: V) => void) | undefined} */\n\tvar setter;\n\n\tif (bindable) {\n\t\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t\t// or `createClassComponent(Component, props)`\n\t\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\t\tsetter =\n\t\t\tget_descriptor(props, key)?.set ??\n\t\t\t(is_entry_props && key in props ? (v) => (props[key] = v) : undefined);\n\t}\n\n\tvar initial_value;\n\tvar is_store_sub = false;\n\n\tif (bindable) {\n\t\t[initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tinitial_value = /** @type {V} */ (props[key]);\n\t}\n\n\tif (initial_value === undefined && fallback !== undefined) {\n\t\tinitial_value = get_fallback();\n\n\t\tif (setter) {\n\t\t\tif (runes) e.props_invalid_value(key);\n\t\t\tsetter(initial_value);\n\t\t}\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\n\t\t\tif (value !== undefined) {\n\t\t\t\t// in legacy mode, we don't revert to the fallback value\n\t\t\t\t// if the prop goes from defined to undefined. The easiest\n\t\t\t\t// way to model this is to make the fallback undefined\n\t\t\t\t// as soon as the prop has a value\n\t\t\t\tfallback_value = /** @type {V} */ (undefined);\n\t\t\t}\n\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// prop is never written to — we only need a getter\n\tif (runes && (flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// prop is written to, but the parent component had `bind:foo` which\n\t// means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn getter();\n\t\t};\n\t}\n\n\t// Either prop is written to, but there's no binding, which means we\n\t// create a derived that we can write to locally.\n\t// Or we are in legacy mode where we always create a derived to replicate that\n\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\tvar d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(getter);\n\n\t// Capture the initial value if it's bindable\n\tif (bindable) get(d);\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;\n\n\t\t\tset(d, new_value);\n\n\t\t\tif (fallback_value !== undefined) {\n\t\t\t\tfallback_value = new_value;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\t// TODO is this still necessary post-#16263?\n\t\tif (has_destroyed_component_ctx(d)) {\n\t\t\treturn d.v;\n\t\t}\n\n\t\treturn get(d);\n\t};\n}\n","<script lang=\"ts\">\n\n    import {type TogglReportItem} from \"../lib/toggl\";\n\n    type ReportPanelProps = {\n        report: TogglReportItem[];\n        date: string;\n    }\n\n    let {report, date}: ReportPanelProps = $props();\n\n    let clickedItems: Set<string> = new Set();\n\n    let totalSeconds = report.reduce((acc, item) => acc + item.seconds, 0);\n\n    function formatDuration(seconds: number): string {\n        const hours = Math.floor(seconds / 3600);\n        const minutes = Math.floor((seconds % 3600) / 60);\n        return `${hours}:${minutes.toString().padStart(2, '0')}`;\n    }\n\n    function onItemClick(item: TogglReportItem) {\n        // dispatch('itemClick', {item});\n    }\n\n    // function onOutsideClick(event: MouseEvent) {\n    //     if (event.target === event.currentTarget) {\n    //         dispatch('close');\n    //     }\n    // }\n</script>\n\n<div id=\"toggl_report\" class=\"report-panel\">\n    {#if report.length === 0}\n        <p>[No time tracked in Toggl]</p>\n    {:else}\n        {#each report as item, index}\n            {@const itemId = `${date}_${item.project?.id}`}\n            {@const isClicked = clickedItems.has(itemId)}\n\n            <div class=\"report-item\" class:clicked={isClicked}\n                 tabindex={index}\n                 role=\"button\"\n                 onclick={() => onItemClick(item)}\n                 onkeydown={(event) => {\n                     if (event.key === 'Enter') {\n                         onItemClick(item);\n                     }\n                 }}>\n                <h4 style=\"color: {isClicked ? 'lightgray' : item.color}\">\n                    {formatDuration(item.seconds)} •\n                    {item.project?.name || 'Unknown Project'} •\n                    {item.project?.client?.name || ''}\n                </h4>\n                <p style=\"color: {isClicked ? 'lightgray' : 'black'}\">\n                    {item.description}\n                </p>\n            </div>\n        {/each}\n\n        <h3 class=\"total\">\n            {formatDuration(totalSeconds)}\n        </h3>\n    {/if}\n</div>\n\n<style>\n    .report-panel {\n        position: relative;\n        top: 0;\n        left: 0;\n        width: 360px;\n        z-index: 100;\n        padding: 1rem;\n        background: white;\n        border: 1px solid gray;\n        border-radius: 3px;\n        text-transform: none;\n        font-family: Roboto, sans-serif;\n        font-size: 0.875rem;\n        font-weight: 400;\n    }\n\n    .report-item {\n        cursor: pointer;\n        margin: 0.5rem;\n    }\n\n    h4 {\n        font-weight: 900;\n        margin-bottom: 0;\n    }\n\n    .total {\n        margin: 0.5rem;\n        font-weight: 900;\n    }\n\n    .clicked h4, .clicked p {\n        color: lightgray;\n    }\n</style>\n","<script lang=\"ts\">\n    import ReportPanel from \"./ReportPanel.svelte\";\n\n    let {panelVisible} = $props();\n\n    function onClick() {\n        panelVisible = !panelVisible;\n    }\n\n    /**\n     * Handle document click to close the report panel\n     */\n    function onDocumentClick(event: MouseEvent): void {\n        const panel = document.getElementById('toggl_report');\n        if (panel && !panel.contains(event.target as Node) && event.target !== document.getElementById('toggl_button')) {\n            panelVisible = false;\n        }\n    }\n    document.addEventListener('click', onDocumentClick);\n</script>\n\n<button id=\"toggl_button\" onclick={onClick}>Toggl</button>\n{#if panelVisible}\n    <ReportPanel\n            report={[]}\n            date=\"TEST\"\n    />\n{/if}\n\n<style>\n    button {\n        display: block;\n        margin-top: 1.5rem;\n        cursor: pointer;\n    }\n</style>\n","/**\n * Content script for Ruddr integration\n */\nimport TogglButton from './TogglButton.svelte';\n// import ReportPanel from './ReportPanel.svelte';\nimport {togglFetchReport, togglSaveProjectMapping, type TogglReportItem} from '../lib/toggl';\nimport {mount} from \"svelte\";\n\n// Global state\nlet togglLastProjectIdClicked: string | null = null;\nlet togglLastReportDate: string = '_';\nconst togglClickedReportItems: Set<string> = new Set();\n\nexport function togglInit(): void {\n    const observer = new MutationObserver(mutations => {\n        togglAddButton();\n    });\n    observer.observe(document.body, { childList: true });\n    // TODO: Is it possible to observe not the entire body?\n}\n\n/**\n * Find an element with specific text content\n */\nfunction togglFindElementWithText(startElement: Element, selector: string, text: string): Element | null {\n    const elements = startElement.querySelectorAll(selector);\n    for (const element of elements) {\n        if (element.textContent === text) {\n            return element;\n        }\n    }\n    return null;\n}\n\n/**\n * Add the Toggl button to the Ruddr form\n */\nfunction togglAddButton(): void {\n    // Don't add if already exists\n    if (document.getElementById('toggl_button')) {\n        return;\n    }\n\n    // Find the dialog\n    const dialogDiv = document.querySelector('body > div:last-of-type');\n    if (!dialogDiv) {\n        return;\n    }\n\n    // Check if it's the New Entry dialog\n    const header = togglFindElementWithText(dialogDiv as Element, 'header h5', 'New Entry');\n    if (!header) {\n        return; // not the New Entry dialogue\n    }\n\n    // Find the form\n    const form = dialogDiv.querySelector('form');\n    if (!form) {\n        // Wait for the form to be loaded\n        const dialogObserver = new MutationObserver(() => {\n            dialogObserver.disconnect();\n            togglAddButton();\n        });\n        dialogObserver.observe(dialogDiv, {childList: true, subtree: true});\n        return;\n    }\n\n    // Find the entry details header\n    const entryDetailsHeader = form.querySelector('div:nth-child(2) > div > div');\n    if (!entryDetailsHeader) {\n        return;\n    }\n\n    // Create a container for the button\n    const buttonContainer = document.createElement('p');\n    entryDetailsHeader.appendChild(buttonContainer);\n\n    // Create and mount the Toggl button component\n    mount(TogglButton, {\n        target: buttonContainer,\n        props: {\n            panelVisible: false\n        }\n    });\n}\n\n/**\n * Handle Toggl button click\n */\nasync function onTogglButtonClick(): Promise<void> {\n    if (document.getElementById('toggl_report')) {\n        // togglRemoveReportPanel();\n    } else {\n        const date = togglGetReportDate();\n        togglLastReportDate = date;\n        console.log(`Fetching Toggl report for date: ${date}`);\n\n        try {\n            const report = await togglFetchReport(date);\n            console.log('Got report', report);\n            // togglShowReportPanel(report);\n        } catch (err) {\n            console.warn(err);\n        }\n    }\n}\n\n/**\n * Get the date from the form\n */\nfunction togglGetReportDate(): string {\n    const form = togglFindForm();\n    const dateInput = form?.querySelector('input[name=\"date\"]');\n    // @ts-ignore - moment is loaded globally\n    return moment(dateInput?.value, 'DD/MM/YYYY').format('YYYY-MM-DD');\n}\n\n/**\n * Find the form element\n */\nfunction togglFindForm(): HTMLFormElement | null {\n    const dialogDiv = document.querySelector('body > div:last-of-type');\n    if (!dialogDiv) {\n        return null;\n    }\n    return dialogDiv.querySelector('form');\n}\n\n/**\n * Fill the form with data from a report item\n */\nfunction togglFillFormFromReport(item: TogglReportItem): void {\n    togglLastProjectIdClicked = item?.project?.id || null;\n    const itemId = `${togglLastReportDate}_${item?.project?.id}`;\n    togglClickedReportItems.add(itemId);\n\n    const form = togglFindForm();\n\n    // Set duration\n    const duration = form?.querySelector('input[name=\"minutes\"]');\n    if (duration) {\n        // @ts-ignore - moment is loaded globally\n        const formattedDuration = togglFormatDuration(moment.duration(item.seconds, 'seconds'));\n        togglSetInputValue(duration as HTMLInputElement, formattedDuration);\n    }\n\n    // Set description\n    const description = form?.querySelector('textarea[name=\"notes\"]');\n    if (description) {\n        (description as HTMLTextAreaElement).style.height = `${(description as HTMLTextAreaElement).scrollHeight}px`;\n        togglSetInputValue(description as HTMLTextAreaElement, item.description);\n    }\n\n    // Save project mapping\n    if (togglLastProjectIdClicked) {\n        const mapping = togglGetCustomerProjectActivity();\n        togglSaveProjectMapping(togglLastProjectIdClicked, mapping);\n    }\n\n    // togglRemoveReportPanel();\n}\n\n/**\n * Format duration in hours:minutes format\n */\nfunction togglFormatDuration(duration: any): string {\n    return `${duration.hours()}:${String(duration.minutes()).padStart(2, '0')}`;\n}\n\n/**\n * Set value of an input element and dispatch input event\n */\nfunction togglSetInputValue(target: HTMLInputElement | HTMLTextAreaElement, value: string): void {\n    target.value = value;\n    // Dispatch input event to trigger React state updates\n    const event = new Event('input', {bubbles: true});\n    Object.defineProperty(event, 'target', {writable: false, value: target});\n    target.dispatchEvent(event);\n}\n\n/**\n * Get customer, project, and activity from the form\n */\nfunction togglGetCustomerProjectActivity(): { customer?: string, project?: string, activity?: string } {\n    const customer = togglReadSelect('timesheet_edit_form_customer');\n    const project = togglReadSelect('timesheet_edit_form_project');\n    const activity = togglReadSelect('timesheet_edit_form_activity');\n    return {\n        customer: customer?.id,\n        project: project?.id,\n        activity: activity?.id\n    };\n}\n\n/**\n * Read value from a select element\n */\nfunction togglReadSelect(selectId: string): { id?: string } {\n    const select = document.getElementById(selectId) as HTMLSelectElement;\n    if (!select) {\n        return {};\n    }\n    return {\n        id: select.value\n    };\n}\n"],"names":["fn","index","$.derived","$.get","$.set_style","$.set_text","$.template_effect","$.prop"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}